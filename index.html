<!DOCTYPE html>
<html lang="ko">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>ìŠ¤íŠ¸ë¦¬ë¨¸ìš© ì‚¬ê²©í˜• ë£°ë ›</title>
<style>
  body {
    font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
    background: #121212;
    color: #eee;
    margin: 0;
    padding: 20px;
    display: flex;
    flex-direction: column;
    align-items: center;
  }
  #container {
    display: flex;
    gap: 20px;
  }
  #mapContainer {
    position: relative;
    width: 500px;
    height: 500px;
    background: #222;
    border-radius: 15px;
    box-shadow: 0 0 20px #0f0;
  }
  canvas {
    display: block;
    background: #111;
    border-radius: 15px;
  }
  #deadListContainer {
    width: 220px;
    background: #222;
    border-radius: 10px;
    padding: 10px;
    color: #f55;
    box-shadow: 0 0 10px #f55;
    height: 500px;
    overflow-y: auto;
  }
  #deadListContainer h3 {
    margin-top: 0;
    text-align: center;
    font-weight: 700;
    color: #f55;
  }
  #deadList {
    list-style: none;
    padding-left: 10px;
  }
  #deadList li {
    padding: 6px 4px;
    border-bottom: 1px solid #f55;
    font-weight: 600;
  }
  #controls {
    margin-top: 20px;
    width: 740px;
    background: #222;
    padding: 15px 20px;
    border-radius: 12px;
    box-shadow: 0 0 15px #0f0;
  }
  textarea, select, input[type=number] {
    width: 100%;
    padding: 8px;
    margin-top: 6px;
    margin-bottom: 12px;
    border-radius: 6px;
    border: none;
    outline: none;
    font-size: 14px;
  }
  label {
    font-weight: 600;
  }
  button {
    padding: 10px 18px;
    font-size: 16px;
    font-weight: 700;
    border-radius: 10px;
    border: none;
    background: #0f0;
    color: #111;
    cursor: pointer;
    transition: background 0.3s ease;
  }
  button:hover:not(:disabled) {
    background: #2f2;
  }
  button:disabled {
    background: #555;
    cursor: not-allowed;
  }
</style>
</head>
<body>

<h1>ìŠ¤íŠ¸ë¦¬ë¨¸ ì „ìš© ì‚¬ê²©í˜• ë£°ë ›</h1>

<div id="container">
  <div id="mapContainer">
    <canvas id="gameMap" width="500" height="500"></canvas>
  </div>
  <div id="deadListContainer">
    <h3 id="deadListTitle">íƒˆë½ì ë¦¬ìŠ¤íŠ¸</h3>
    <ul id="deadList"></ul>
  </div>
</div>

<div id="controls">
  <label for="playerInput">ì°¸ê°€ì ì´ë¦„ (í•œ ì¤„ì— í•œ ëª…ì”©, ì‰¼í‘œë„ ê°€ëŠ¥)</label>
  <textarea id="playerInput" rows="4" placeholder="ì°¸ê°€ì ì´ë¦„ì„ ì…ë ¥í•˜ì„¸ìš”"></textarea>

  <label for="winnerCount">ë‹¹ì²¨ì ìˆ˜</label>
  <input type="number" id="winnerCount" min="1" value="1" />

  <label for="modeSelect">ë‹¹ì²¨ì ì„ ì • ë°©ì‹</label>
  <select id="modeSelect">
    <option value="survival">ìƒì¡´ ë°©ì‹ (ëœë¤ íƒˆë½)</option>
    <option value="targeting">íƒ€ê²ŒíŒ… ë°©ì‹ (ì¦‰ì‹œ ë‹¹ì²¨)</option>
  </select>

  <label for="mapSelect">ë§µ ì„ íƒ</label>
  <select id="mapSelect">
    <option value="circle">ì›í˜• ë§µ</option>
    <option value="square">ì •ì‚¬ê°í˜• ë§µ</option>
    <option value="polygon">ì¸ì›ìˆ˜ì— ë§ëŠ” ë‹¤ê°í˜• ë§µ</option>
  </select>

  <button id="startBtn">ê²Œì„ ì‹œì‘</button>
</div>

<script>
// JavaScript ì „ì²´ ì½”ë“œ (ìŠ¤í¬ë¦½íŠ¸)

const canvas = document.getElementById('gameMap');
const ctx = canvas.getContext('2d');
const width = canvas.width;
const height = canvas.height;

const playerInput = document.getElementById('playerInput');
const winnerCountInput = document.getElementById('winnerCount');
const modeSelect = document.getElementById('modeSelect');
const mapSelect = document.getElementById('mapSelect');
const startBtn = document.getElementById('startBtn');

const deadUl = document.getElementById('deadList');
const deadListTitle = document.getElementById('deadListTitle');
let players = [];
let deadList = [];
let winners = [];
let gameRunning = false;

function drawPolygon(ctx, centerX, centerY, radius, sides) {
  if(sides < 3) sides = 3;
  ctx.beginPath();
  for(let i = 0; i < sides; i++) {
    const angle = (2 * Math.PI / sides) * i - Math.PI / 2;
    const x = centerX + radius * Math.cos(angle);
    const y = centerY + radius * Math.sin(angle);
    if(i === 0) ctx.moveTo(x, y);
    else ctx.lineTo(x, y);
  }
  ctx.closePath();
  ctx.stroke();
}

function drawMap(ctx, type){
  ctx.clearRect(0, 0, width, height);
  ctx.strokeStyle = '#0f0';
  ctx.lineWidth = 4;
  ctx.shadowColor = '#0f0';
  ctx.shadowBlur = 15;

  if(type === 'circle'){
    ctx.beginPath();
    ctx.arc(width/2, height/2, 230, 0, Math.PI*2);
    ctx.stroke();
  } else if(type === 'square'){
    ctx.strokeRect(30, 30, width - 60, height - 60);
  } else if(type === 'polygon'){
    const sides = players.length >= 3 ? players.length : 3;
    drawPolygon(ctx, width/2, height/2, 230, sides);
  }
  ctx.shadowBlur = 0;
}

function getPlayerPosition(index, total, radius=200){
  const centerX = width/2;
  const centerY = height/2;
  const angle = (index / total) * 2 * Math.PI - Math.PI / 2;
  const x = centerX + radius * Math.cos(angle);
  const y = centerY + radius * Math.sin(angle);
  return {x, y};
}

function drawPlayers(playerList) {
  ctx.font = 'bold 20px Arial';
  ctx.textAlign = 'center';
  ctx.textBaseline = 'middle';

  playerList.forEach((name, idx) => {
    const {x, y} = getPlayerPosition(idx, playerList.length);
    ctx.fillStyle = '#0f0';
    ctx.shadowColor = '#0f0';
    ctx.shadowBlur = 10;
    ctx.beginPath();
    ctx.arc(x, y, 25, 0, 2*Math.PI);
    ctx.fill();

    ctx.shadowBlur = 0;
    ctx.fillStyle = '#000';
    ctx.fillText(name, x, y);
  });
}

function updateDeadList(deadPlayers) {
  deadUl.innerHTML = '';
  if (deadPlayers.length === 0) return;
  deadPlayers.forEach(name => {
    const li = document.createElement('li');
    li.textContent = name;
    deadUl.appendChild(li);
  });
}

function updateWinnerList(winnerPlayers) {
  deadUl.innerHTML = '';
  if (winnerPlayers.length === 0) return;
  winnerPlayers.forEach(name => {
    const li = document.createElement('li');
    li.textContent = name;
    deadUl.appendChild(li);
  });
}
function sleep(ms) {
  return new Promise(resolve => setTimeout(resolve, ms));
}

async function shootEffect(shooterPos, targetPos){
  const bulletRadius = 6;
  let progress = 0;
  const speed = 0.05;

  return new Promise(resolve => {
    function animate(){
      ctx.clearRect(0, 0, width, height);
      drawMap(ctx, mapSelect.value);
      drawPlayers(players.filter(p => !deadList.includes(p)));

      const x = shooterPos.x + (targetPos.x - shooterPos.x) * progress;
      const y = shooterPos.y + (targetPos.y - shooterPos.y) * progress;

      ctx.fillStyle = '#f55';
      ctx.shadowColor = '#f55';
      ctx.shadowBlur = 15;
      ctx.beginPath();
      ctx.arc(x, y, bulletRadius, 0, 2*Math.PI);
      ctx.fill();

      progress += speed;

      if(progress < 1){
        requestAnimationFrame(animate);
      } else {
        let flashCount = 0;
        function flash(){
          ctx.clearRect(0, 0, width, height);
          drawMap(ctx, mapSelect.value);
          drawPlayers(players.filter(p => !deadList.includes(p)));

          if(flashCount % 2 === 0){
            ctx.fillStyle = 'rgba(255, 85, 85, 0.8)';
            ctx.shadowColor = '#f55';
            ctx.shadowBlur = 30;
            ctx.beginPath();
            ctx.arc(targetPos.x, targetPos.y, 40, 0, 2*Math.PI);
            ctx.fill();
          }
          flashCount++;
          if(flashCount < 6){
            setTimeout(flash, 100);
          } else {
            resolve();
          }
        }
        flash();
      }
    }
    animate();
  });
}

async function survivalMode(remaining, winnerCount, mapId) {
  deadListTitle.textContent = 'íƒˆë½ì ë¦¬ìŠ¤íŠ¸';
  const aiPos = { x: canvas.width / 2, y: canvas.height / 2 };
  const aimInterval = 50;       // íšŒì „ ì£¼ê¸°(ms)
  const rotationSpeed = 0.15;   // íšŒì „ ì†ë„ (ë¼ë””ì•ˆ)

  const totalPlayers = remaining.length + deadList.length;

  function normalizeAngle(angle) {
    while (angle < 0) angle += Math.PI * 2;
    while (angle >= Math.PI * 2) angle -= Math.PI * 2;
    return angle;
  }

  let currentAngle = 0;
  currentAngle = normalizeAngle(currentAngle);

  let lastShotTime = Date.now();
  let delayAfterShot = 0;
  let pendingShot = null;

  while (true) {
    const now = Date.now();
    const timeSinceLastShot = now - lastShotTime;

    // íšŒì „
    currentAngle += rotationSpeed;
    currentAngle = normalizeAngle(currentAngle);

    drawMap(ctx, mapId);
    drawPlayers(remaining);
    drawAI(ctx, aiPos, currentAngle);
    updateDeadList(deadList);

    // íƒˆë½ì ì„ ì • ëŒ€ê¸° ì¤‘ì¼ ë•Œë§Œ ìƒˆë¡œìš´ íƒ€ê²Ÿ ì„ ì •
    if (!pendingShot && timeSinceLastShot >= delayAfterShot && remaining.length > winnerCount) {
      const loseIndex = Math.floor(Math.random() * remaining.length);
      const loserPos = getPlayerPosition(loseIndex, remaining.length);
      pendingShot = { index: loseIndex, pos: loserPos };
    }

    if (pendingShot) {
      const { index: loseIndex, pos: loserPos } = pendingShot;

      const dx = loserPos.x - aiPos.x;
      const dy = loserPos.y - aiPos.y;
      const targetAngle = normalizeAngle(Math.atan2(dy, dx));

      let diff = targetAngle - currentAngle;
      if (diff > Math.PI) diff -= 2 * Math.PI;
      if (diff < -Math.PI) diff += 2 * Math.PI;

      // ì¼ì • ê°ë„ ì´ë‚´ë©´ ì‚¬ê²©
      if (Math.abs(diff) < 0.2) {
        await shootEffect(aiPos, loserPos);

        // íƒˆë½ ì²˜ë¦¬
        const removed = remaining.splice(loseIndex, 1)[0];
        deadList.push(removed);

        // ë‹¤ìŒ ì‚¬ê²©ê¹Œì§€ì˜ ì§€ì—° ì‹œê°„ ì„¤ì •
        const minDelay = 300;
        const maxDelay = 3000;
        const currentPlayers = remaining.length;
        const ratio = (totalPlayers - currentPlayers) / totalPlayers;
        delayAfterShot = minDelay + Math.pow(ratio, 3) * (maxDelay - minDelay);
        lastShotTime = Date.now();
        pendingShot = null;

        drawMap(ctx, mapId);
        drawPlayers(remaining);
        drawAI(ctx, aiPos, currentAngle);
        updateDeadList(deadList);
      }
    }

    // ì¢…ë£Œ ì¡°ê±´ í™•ì¸
    if (remaining.length <= winnerCount) {
      break;
    }

    await sleep(aimInterval);
  }

  return remaining;
}

async function targetingMode(remaining, winnerCount, mapId) {
  deadListTitle.textContent = 'ë‹¹ì²¨ì ë¦¬ìŠ¤íŠ¸';
  const aiPos = { x: canvas.width / 2, y: canvas.height / 2 };
  const aimInterval = 50;        // íšŒì „ ì†ë„ ê°„ê²©(ms)
  const rotationSpeed = 0.15;    // íšŒì „ ì†ë„ (ë¼ë””ì•ˆ)
  const angleThreshold = 0.1;    // ë©ˆì¶œ ê°ë„ ì°¨ì´ ì„ê³„ê°’ (ë¼ë””ì•ˆ)

  while (remaining.length > 0 && winners.length < winnerCount) {
    const targetIndex = Math.floor(Math.random() * remaining.length);
    const targetName = remaining[targetIndex];
    const targetPos = getPlayerPosition(targetIndex, remaining.length);

    // ëª©í‘œ ê°ë„
    const dx = targetPos.x - aiPos.x;
    const dy = targetPos.y - aiPos.y;
    const targetAngle = Math.atan2(dy, dx);

    let angle = 0;

    while (true) {
      angle += rotationSpeed;
      if (angle > 2 * Math.PI) angle -= 2 * Math.PI;

      let diff = targetAngle - angle;
      if (diff > Math.PI) diff -= 2 * Math.PI;
      if (diff < -Math.PI) diff += 2 * Math.PI;

      if (Math.abs(diff) < angleThreshold) {
        angle = targetAngle;
        drawMap(ctx, mapId);
        drawPlayers(remaining);
        drawAI(ctx, aiPos, angle);
        break;
      }

      drawMap(ctx, mapId);
      drawPlayers(remaining);
      drawAI(ctx, aiPos, angle);
      await sleep(aimInterval);
    }

    // ì˜ê¸°
    await shootEffect(aiPos, targetPos);

    // ë‹¹ì²¨ì ì²˜ë¦¬
    const removed = remaining.splice(targetIndex, 1)[0];
    winners.push(removed);

    drawMap(ctx, mapId);
    drawPlayers(remaining);
    updateWinnerList(winners); // âœ… ë‹¹ì²¨ì ë¦¬ìŠ¤íŠ¸ ê°±ì‹ 
  }

  return winners;
}

function drawAI(ctx, pos, angle) {
  const len = 60;
  ctx.strokeStyle = '#f55';
  ctx.lineWidth = 2;
  ctx.shadowColor = '#f55';
  ctx.shadowBlur = 15;
  ctx.beginPath();
  ctx.moveTo(pos.x, pos.y);
  ctx.lineTo(pos.x + len * Math.cos(angle), pos.y + len * Math.sin(angle));
  ctx.stroke();
  ctx.shadowBlur = 0;
}

function normalizeAngle(angle) {
  while (angle < -Math.PI) angle += 2 * Math.PI;
  while (angle > Math.PI) angle -= 2 * Math.PI;
  return angle;
}

function validateInput(){
  if(players.length < 2){
    alert('ì°¸ê°€ìëŠ” ìµœì†Œ 2ëª… ì´ìƒì´ì–´ì•¼ í•©ë‹ˆë‹¤.');
    return false;
  }
  let winnerCount = parseInt(winnerCountInput.value);
  if(isNaN(winnerCount) || winnerCount < 1){
    alert('ë‹¹ì²¨ì ìˆ˜ë¥¼ ì˜¬ë°”ë¥´ê²Œ ì…ë ¥í•˜ì„¸ìš”.');
    return false;
  }
  if(winnerCount >= players.length){
    alert('ë‹¹ì²¨ì ìˆ˜ëŠ” ì°¸ê°€ì ìˆ˜ë³´ë‹¤ ì ì–´ì•¼ í•©ë‹ˆë‹¤.');
    return false;
  }
  return true;
}

function updatePlayersFromInput(){
  players = playerInput.value.trim()
    .split(/[\n,]+/)
    .map(p => p.trim())
    .filter(p => p.length > 0);

  deadList = [];
  winners = [];
  drawMap(ctx, mapSelect.value);
  drawPlayers(players);
  updateDeadList(deadList);
}

async function runGame(){
  if(gameRunning) return;
  if(!validateInput()) return;
  gameRunning = true;
  deadList = [];
  winners = [];
  let winnerCount = parseInt(winnerCountInput.value);
  let mode = modeSelect.value;
  let mapId = mapSelect.value;
  let remaining = players.slice();

  drawMap(ctx, mapId);
  drawPlayers(remaining);
  updateDeadList(deadList);

  if(mode === 'survival'){
    winners = await survivalMode(remaining, winnerCount, mapId);
  } else {
    winners = await targetingMode(remaining, winnerCount, mapId);
  }

  ctx.clearRect(0, 0, width, height);
  drawMap(ctx, mapId);
  ctx.font = 'bold 28px Arial';
  ctx.fillStyle = '#0f0';
  ctx.textAlign = 'center';
  ctx.textBaseline = 'middle';
  ctx.shadowColor = '#0f0';
  ctx.shadowBlur = 20;

  let text = `ğŸ‰ ë‹¹ì²¨ì (${winners.length}ëª…) ğŸ‰\n` + winners.join(', ');
  const lines = text.split('\n');
  lines.forEach((line, idx) => {
    ctx.fillText(line, width/2, height/2 + idx*40);
  });
  gameRunning = false;
}

updatePlayersFromInput();
playerInput.addEventListener('input', () => {
  if(!gameRunning) updatePlayersFromInput();
});
startBtn.addEventListener('click', runGame);
</script>

</body>
</html>
