<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>캐릭터 사격 추첨기</title>
  <style>
    body { font-family: Arial, sans-serif; background: #f4f4f4; text-align: center; padding: 20px; }
    #game-area { width: 2000px; height: 1000px; margin: 20px auto; background: #d3e0ea; border: 3px solid #333; position: relative; overflow: hidden; cursor: crosshair; }
    .character { position: absolute; width: 60px; height: 60px; background: url('https://upload.wikimedia.org/wikipedia/commons/8/89/Portrait_Placeholder.png') no-repeat center/contain; bottom: 0; left: 50%; transform: translateX(-50%); }
    .target { position: absolute; width: 50px; height: 50px; background: #888; border-radius: 50%; display: flex; align-items: center; justify-content: center; font-weight: bold; color: white; user-select: none; }
    .target.alive { color: transparent; }
    .target.hit { background: red; color: white; }
    .target.eliminated { background: gray; color: white; }
    .target.invisible { visibility: hidden; }
    .bullet { position: absolute; width: 10px; height: 20px; background: black; border-radius: 5px; pointer-events: none; }
    .obstacle { position: absolute; width: 60px; height: 60px; background: brown; border-radius: 10px; }
    button, input { font-size: 1em; margin: 5px; }
  </style>
</head>
<body>
  <h1>🎯 캐릭터 사격 추첨기</h1>

  <label>참가자 (콤마): 
    <input type="text" id="participants" placeholder="예: 김보라, 이준호, 송다혜" size="40" />
  </label>
  <label>당첨 수: 
    <input type="number" id="winnerCount" value="1" min="1" max="100000" />
  </label><br>

  <label><input type="radio" name="mode" value="hit" checked> 잡은 사람</label>
  <label><input type="radio" name="mode" value="survivor"> 생존자</label><br>

  <label>속도: 
    <input type="range" id="speedRange" min="0" max="100" step="1" value="1" />
    <span id="speedValue">1.0</span>
  </label><br>

  <button id="startBtn">시작</button>
  <button id="resetBtn" disabled>초기화</button><br>

  <div id="game-area" tabindex="0">
    <div class="character" id="shooter"></div>
  </div>

  <div id="results"></div>

  <script>
    const participantsInput = document.getElementById('participants');
    const winnerCountInput = document.getElementById('winnerCount');
    const modeInputs = document.getElementsByName('mode');
    const speedRange = document.getElementById('speedRange');
    const speedValue = document.getElementById('speedValue');
    const startBtn = document.getElementById('startBtn');
    const resetBtn = document.getElementById('resetBtn');
    const gameArea = document.getElementById('game-area');
    const shooter = document.getElementById('shooter');
    const results = document.getElementById('results');

    let participants = [];
    let winnerCount = 1;
    let mode = 'hit';
    let baseSpeed = parseFloat(speedRange.value);
    let shootingActive = false;
    let targets = [];
    let obstacles = [];
    let winners = [];
    let movements = new Map();
    let obstacleIntervalId = null;

    let startTime = 0;

    speedRange.oninput = () => {
      baseSpeed = parseFloat(speedRange.value);
      speedValue.textContent = baseSpeed.toFixed(1);
    };

    startBtn.onclick = () => {
      participants = participantsInput.value.split(',').map(s=>s.trim()).filter(s=>s);
      winnerCount = parseInt(winnerCountInput.value);
      mode = Array.from(modeInputs).find(r=>r.checked).value;
      if(!participants.length || winnerCount<1 || winnerCount>participants.length) {
        alert('입력 확인');
        return;
      }

      shootingActive = true; 
      winners = []; 
      results.innerHTML = '';
      clearAll();
      createObstacles(8);
      createTargets();
      createBlinking(); // 깜빡이기 시작
      setupMovements();
      startTime = performance.now();
      requestAnimationFrame(moveTargets);

      obstacleIntervalId = setInterval(() => {
        if (!shootingActive) return;
        createObstacles(2);
      }, 5000);

      resetBtn.disabled = false; 
      startBtn.disabled = true;
      gameArea.focus();
    };

    resetBtn.onclick = () => {
      shootingActive = false;
      clearAll();
      clearInterval(obstacleIntervalId);
      startBtn.disabled = false;
      resetBtn.disabled = true;
    };

    gameArea.onclick = e => {
      if(!shootingActive) return;
      const rect = gameArea.getBoundingClientRect();
      shoot(e.clientX - rect.left, e.clientY - rect.top);
    };

    gameArea.onkeydown = e => {
      if(!shootingActive) return;
      let x = shooter.offsetLeft;
      if (e.key === 'ArrowLeft' || e.key === 'a' || e.key === 'A') x -= 20;
      if (e.key === 'ArrowRight' || e.key === 'd' || e.key === 'D') x += 20;
      x = Math.max(0, Math.min(x, gameArea.clientWidth - shooter.offsetWidth));
      shooter.style.left = x + 'px';
    };

    function shoot(tx, ty) {
      const b = document.createElement('div'); b.className='bullet';
      gameArea.appendChild(b);
      let x = shooter.offsetLeft + shooter.offsetWidth/2, y = gameArea.clientHeight-60;
      const dx = (tx-x), dy=(ty-y);
      const dist = Math.hypot(dx,dy), vx=dx/dist*15, vy=dy/dist*15;
      b.style.left=x+'px'; b.style.bottom=(gameArea.clientHeight-y)+'px';

      (function mb(){
        if(!b.parentNode) return;
        x+=vx; y+=vy;
        b.style.left=x+'px'; b.style.bottom=(gameArea.clientHeight-y)+'px';
        if(x<0||y<0||x>gameArea.clientWidth||y>gameArea.clientHeight){ b.remove(); return; }
        for(let o of obstacles){
          const or = o.getBoundingClientRect(), br = b.getBoundingClientRect();
          if(br.right>or.left && br.left<or.right && br.bottom>or.top && br.top<or.bottom){ b.remove(); return; }
        }
        for(let t of targets){
          if(t.dataset.eliminated==='true') continue;
          const tr = t.getBoundingClientRect(), br = b.getBoundingClientRect();
          if(br.right>tr.left && br.left<tr.right && br.bottom>tr.top && br.top<tr.bottom){
            hit(t); b.remove(); return;
          }
        }
        requestAnimationFrame(mb);
      })();
    }

    function hit(t){
      t.dataset.eliminated='true';
      t.classList.remove('alive');
      t.classList.add(mode==='hit'?'hit':'eliminated');
      t.innerText = t.dataset.name;
      if(mode==='hit'){
        winners.push(t.dataset.name);
        if(winners.length>=winnerCount) finish();
      } else {
        winners.push(t.dataset.name);
        if(participants.length - winners.length <= winnerCount) finish();
      }
    }

    function finish(){
      shootingActive = false;
      clearInterval(obstacleIntervalId);
      const win = mode==='hit' ? winners : participants.filter(p=>!winners.includes(p));
      results.innerHTML = `<strong>🎉 당첨자:</strong> ${win.join(', ')}`;
    }

    function clearAll(){
      targets.forEach(t=>t.remove()); targets=[]; movements.clear();
      obstacles.forEach(o=>o.remove()); obstacles=[];
      document.querySelectorAll('.bullet').forEach(b=>b.remove());
    }

    function createObstacles(n){
      for(let i=0; i<n; i++){
        const o = document.createElement('div'); o.className='obstacle';
        const x = Math.random()*(gameArea.clientWidth-60),
              y = Math.random()*(gameArea.clientHeight-200);
        o.style.left = x + 'px'; 
        o.style.top = y + 'px';
        gameArea.appendChild(o); obstacles.push(o);
      }
    }

    function createTargets(){
      for(let i=0; i<participants.length; i++){
        const t = document.createElement('div'); t.className='target alive';
        t.dataset.name = participants[i];
        const x = Math.random()*(gameArea.clientWidth-50),
              y = Math.random()*(gameArea.clientHeight-150);
        t.style.left = x + 'px'; 
        t.style.top = y + 'px'; 
        t.dataset.eliminated = 'false';
        gameArea.appendChild(t); targets.push(t);
      }
      shooter.style.left = (gameArea.clientWidth/2 - shooter.offsetWidth/2) + 'px';
    }

    function setupMovements(){
      movements.clear();
      for(let t of targets){
        const ang = Math.random()*2*Math.PI;
        movements.set(t, {dx:Math.cos(ang)*baseSpeed, dy:Math.sin(ang)*baseSpeed});
      }
    }

    function moveTargets(time) {
      if (!shootingActive) return;
      // 경과 시간(초)
      const elapsedSec = (time - startTime) / 1000;
      const currentSpeed = baseSpeed + Math.floor(elapsedSec);

      targets.forEach(t => {
        if (t.dataset.eliminated === 'true') return;

        const mv = movements.get(t);
        if (!mv) return;

        // 방향 벡터 단위화
        const angle = Math.atan2(mv.dy, mv.dx);
        mv.dx = Math.cos(angle) * currentSpeed;
        mv.dy = Math.sin(angle) * currentSpeed;

        let x = parseFloat(t.style.left);
        let y = parseFloat(t.style.top);
        let newX = x + mv.dx;
        let newY = y + mv.dy;

        // 게임 영역 밖으로 나가면 방향 반전
        if (newX < 0 || newX > gameArea.clientWidth - 50) mv.dx = -mv.dx;
        if (newY < 0 || newY > gameArea.clientHeight - 150) mv.dy = -mv.dy;

        // 장애물과 충돌 검사
        let collided = false;
        for (let o of obstacles) {
          const ox = parseFloat(o.style.left);
          const oy = parseFloat(o.style.top);
          const ow = o.offsetWidth;
          const oh = o.offsetHeight;

          const tw = t.offsetWidth;
          const th = t.offsetHeight;

          if (
            newX < ox + ow &&
            newX + tw > ox &&
            newY < oy + oh &&
            newY + th > oy
          ) {
            collided = true;
            break;
          }
        }

        // 충돌했으면 방향 반전
        if (collided) {
          mv.dx = -mv.dx;
          mv.dy = -mv.dy;
        } else {
          t.style.left = newX + 'px';
          t.style.top = newY + 'px';
        }
      });

      requestAnimationFrame(moveTargets);
    }

    function createBlinking(){
      let invisibleDuration = 600;
      let blinkInterval = 4000;
      let isInvisible = false;

      function blink() {
        if (!shootingActive) return;
        targets.forEach(t => {
          if (t.dataset.eliminated === 'true') return;
          if(isInvisible) {
            t.classList.remove('invisible');
          } else {
            t.classList.add('invisible');
          }
        });
        isInvisible = !isInvisible;
        setTimeout(() => {
          if (!shootingActive) return;
          blink();
        }, isInvisible ? invisibleDuration : blinkInterval - invisibleDuration);
      }
      blink();
    }

  </script>
</body>
</html>
